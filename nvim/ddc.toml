# 補完plugin
[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['denops.vim', 'pum.vim']
on_event = ['InsertEnter', 'CmdlineEnter']
lua_source = '''
if vim.fn.has('wsl') == 1 then
	vim.opt_local.dictionary:append('/usr/share/dict/american-english')
	vim.fn["ddc#custom#patch_global"]({
		sourceParams = {
			dictionary = {
				paths = { '/usr/share/dict/american-english' }
			}
		},
		filterParams = {
			converter_dictionary = {
				dicts = { vim.g.github_dir .. "/gunyarakun/kantan-ej-dictionary/kantan-ej-dictionary.json" }
			}
		}
	})
end

vim.fn["ddc#custom#patch_global"]({
	ui = "pum",
	sources = { "around", "lsp", "vsnip", "file", "dictionary" },
	sourceOptions = {
		around = { mark = "A" },
		["lsp"] = {
			mark = "lsp",
			dup = "force",
			keywordPattern = "\\k+",
			forceCompletionPattern = "\\.\\w*|::",
			matchers = { "matcher_fuzzy" },
			sorters = { "sorter_fuzzy" },
			converters = { "converter_fuzzy", "converter_kind_labels" }
		},
		dictionary = {
			mark = "Dic",
			minKeywordLength = 4,
			converters = { "converter_fuzzy", "converter_dictionary" }
		},
		vsnip = { mark = "Snip", dup = "keep" },
		file = {
			mark = "F",
			isVolatile = true,
			forceCompletionPattern = "\\S/\\S*"
		},
		cmdline = { mark = "cmd" },
		["cmdline-history"] = { mark = "his", dup = "ignore" },
		input = { mark = "in", isVolatile = true },
		skkeleton = {
			mark = "skkeleton",
			matchers = {},
			sorters = {},
			minAutoCompleteLength = 0,
			isVolatile = true
		},
		_ = {
			matchers = { "matcher_fuzzy" },
			sorters = { "sorter_fuzzy" },
			converters = { "converter_fuzzy" }
		}
	},
	sourceParams = {
		["lsp"] = {
			enableResolveItem = true,
			enableAdditionalTextEdit = true,
			confirmBehavior = "replace",
			snippetEngine = vim.fn["denops#callback#register"](function(body)
				vim.fn["vsnip#anonymous"](body)
			end)
		},
		file = {
			mode = "os"
		},
	},
	filterParams = {
		converter_fuzzy = {
			hlGroup = "Blue"
		},
		-- lspのkindのVSCode-likeなアイコンを表示する
		-- https://code.visualstudio.com/docs/editor/intellisense#_types-of-completions
		converter_kind_labels = {
			kindLabels = {
				Text = "",
				Method = "",
				Function = "",
				Constructor = "",
				Field = "",
				Variable = "",
				Class = "",
				Interface = "",
				Module = "",
				Property = "",
				Unit = "",
				Value = "",
				Enum = "",
				Keyword = "",
				Snippet = "",
				Color = "",
				File = "",
				Reference = "",
				Folder = "",
				EnumMember = "",
				Constant = "",
				Struct = "",
				Event = "",
				Operator = "",
				TypeParameter = ""
			},
			kindHlGroups = {
				Method = "Function",
				Function = "Function",
				Constructor = "Function",
				Field = "Identifier",
				Variable = "Identifier",
				Class = "Structure",
				Interface = "Structure",
				Module = "Structure",
				Property = "Identifier",
				Value = "Type",
				Enum = "Type",
				File = "Structure",
				Event = "Type"
			}
		},
	},
	autoCompleteEvents = {
		"InsertEnter",
		"TextChangedI", "TextChangedP",
		"CmdlineChanged", "CmdlineEnter"
	},
	cmdlineSources = {
		[":"] = { "cmdline", "cmdline-history" },
		["@"] = { "input", "around" }
	}
})

vim.fn["ddc#custom#patch_filetype"]("gina-commit", {
	specialBufferCompletion = true,
})
vim.fn["ddc#custom#patch_filetype"]("traqvim-message", {
	sources = { "stamp" },
	sourceOptions = {
		stamp = {
			mark = "stamp",
			matchers = { "matcher_fuzzy" },
			keywordPattern = "[a-zA-Z_:]\\w*",
		}
	},
	specialBufferCompletion = true,
})

vim.fn["ddc#enable"]()

-- use pum
vim.api.nvim_create_autocmd({ "CmdlineEnter" }, {
	pattern = "*",
	callback = function()
		vim.fn["ddc#enable_cmdline_completion"]()
	end
})
'''

# 補完UI
[[plugins]]
repo = 'Shougo/ddc-ui-native'
on_source = 'ddc.vim'

# 独自ポップアップwindow
[[plugins]]
repo = 'Shougo/pum.vim'
lua_source = '''
vim.keymap.set('i', '<C-n>', function()
	vim.fn["pum#map#select_relative"](1)
end)
vim.keymap.set('i', '<C-p>', function()
	vim.fn["pum#map#select_relative"](-1)
end)
vim.keymap.set('i', '<C-y>', function()
	vim.fn["pum#map#confirm"]()
end)
vim.keymap.set('i', '<C-e>', function()
	vim.fn["pum#map#cancel"]()
end)
vim.keymap.set('c', '<C-n>', function()
	if vim.fn["pum#visible"]() then
		return "<Cmd>call pum#map#select_relative(+1)<CR>"
	else
		return "<C-n>"
	end
end, { expr = true })
vim.keymap.set('c', '<C-p>', function()
	if vim.fn["pum#visible"]() then
		return "<Cmd>call pum#map#select_relative(-1)<CR>"
	else
		return "<C-p>"
	end
end, { expr = true })
vim.keymap.set('c', '<CR>', function()
	if vim.fn["pum#visible"]() then
		return "<Cmd>call pum#map#confirm()<CR><CR>"
	else
		return "<CR>"
	end
end, { expr = true })
vim.keymap.set('c', '<C-y>', function()
	vim.fn["pum#map#confirm"]()
end)

vim.opt.cedit = "<C-f>"

vim.fn["pum#set_option"]({
	max_height = 10,
	max_width = 50,
	padding = true,
})

-- leximaの影響を受けちゃうので、insertEnterでマッピングを上書きする
vim.api.nvim_create_autocmd({ "InsertEnter" }, {
	pattern = "*",
	callback = function()
		vim.keymap.set('i', '<CR>', function()
			if vim.fn["pum#visible"]() then
				return "<Cmd>call pum#map#confirm()<CR>"
			else
				return vim.fn["lexima#expand"]('<LT>CR>', 'i')
			end
		end, { remap = true, expr = true })
		vim.keymap.set('i', '<C-n>', function()
			if vim.fn["pum#visible"]() then
				vim.fn['pum#map#select_relative'](1)
			else
				vim.fn["ddc#map#manual_complete"]()
			end
		end, { remap = true })
		vim.keymap.set('i', '<C-p>', function()
			if vim.fn["pum#visible"]() then
				return "<Cmd>call pum#map#select_relative(-1)<CR>"
			else
				return "<Cmd>call ddc#map#manual_complete()<CR>"
			end
		end, { remap = true, expr = true })
	end
})
'''

[[plugins]]
repo = 'Shougo/ddc-ui-pum'
on_source = 'ddc.vim'

# 補完source
[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-lsp'
depends = ['denops.vim', 'ddc.vim']
on_source = 'ddc.vim'

[[plugins]]
repo = 'uga-rosa/ddc-source-dictionary'
on_source = 'ddc.vim'

[[plugins]]
repo = 'LumaKernel/ddc-source-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-cmdline'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-cmdline-history'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-input'
on_source = 'ddc.vim'

# 補完filter
[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

[[plugins]]
repo = 'atusy/ddc-filter-converter_dictionary'
on_source = 'ddc.vim'

# converter_dictionaryで使う辞書
[[plugins]]
repo = 'gunyarakun/kantan-ej-dictionary'

[[plugins]]
repo = 'dwyl/english-words'

# スニペット
[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_source = 'ddc.vim'
lua_add = '''
vim.keymap.set('i', '<Tab>', function()
	if vim.fn["vsnip#jumpable"](1) == 1 then
		return "<Plug>(vsnip-jump-next)"
	else
		return "<Tab>"
	end
end, { remap = true, expr = true })
vim.keymap.set('i', '<S-Tab>', function()
	if vim.fn["vsnip#jumpable"](-1) == 1 then
		return "<Plug>(vsnip-jump-prev)"
	else
		return "<S-Tab>"
	end
end, { remap = true, expr = true })
vim.keymap.set('s', '<Tab>', function()
	if vim.fn["vsnip#jumpable"](1) == 1 then
		return "<Plug>(vsnip-jump-next)"
	else
		return "<Tab>"
	end
end, { remap = true, expr = true })
vim.keymap.set('s', '<S-Tab>', function()
	if vim.fn["vsnip#jumpable"](-1) == 1 then
		return "<Plug>(vsnip-jump-prev)"
	else
		return "<S-Tab>"
	end
end, { remap = true, expr = true })
'''

[[plugins]]
repo = 'uga-rosa/ddc-source-vsnip'
depends = ['vim-vsnip']
on_source = 'ddc.vim'

# SKK
[[plugins]]
repo = 'vim-skk/skkeleton'
on_map = { 'ic' = '<Plug>(skkeleton-toggle)'}
depends = ['ddc.vim']
lua_add = '''
vim.keymap.set('i', '<C-j>', '<Plug>(skkeleton-toggle)', { remap = true })
vim.keymap.set('c', '<C-j>', '<Plug>(skkeleton-toggle)', { remap = true })
'''
lua_source = '''
vim.fn["skkeleton#config"]({
	globalDictionaries = {
		{ vim.fn.expand(vim.g.github_dir .. "/skk-dev/dict/SKK-JISYO.L"), "euc-jp" },
		{ vim.fn.expand(vim.g.rc_dir .. "/SKK-JISYO.nicoime"),            "utf-16le" },
	},
	registerConvertResult = true,
})
-- `l`で変換モードの変化を無効化
vim.g["skkeleton#mapped_keys"] = vim.fn.extend(vim.g["skkeleton#mapped_keys"], {"<C-l>"})
vim.fn["skkeleton#register_keymap"]("input", "<C-l>", "disable")
vim.fn["skkeleton#register_kanatable"]("rom", {
	l = false,
})
-- シャ・チャ行の入力
vim.fn["skkeleton#register_kanatable"]("rom", {
	xa = { "しゃ" },
	xu = { "しゅ" },
	xe = { "しぇ" },
	xo = { "しょ" },
	xz = { "しゃん" },
	xn = { "しゅん" },
	xj = { "しゅん" },
	xd = { "しぇん" },
	xl = { "しょん" },
	xq = { "しゃい" },
	xh = { "しゅう" },
	xw = { "しぇい" },
	xp = { "しょう" },
	ca = { "ちゃ" },
	cu = { "ちゅ" },
	ce = { "ちぇ" },
	co = { "ちょ" },
	cz = { "ちゃん" },
	cn = { "ちゃん" },
	cj = { "ちゅん" },
	cd = { "ちぇん" },
	cl = { "ちょん" },
	cq = { "ちゃい" },
	ch = { "ちゅう" },
	cw = { "ちぇい" },
	cp = { "ちょう" },
})
-- 特殊な拗音の入力
vim.fn["skkeleton#register_kanatable"]("rom", {
	la = { "ぁ" },
	li = { "ぃ" },
	lu = { "ぅ" },
	le = { "ぇ" },
	lo = { "ぉ" },
	lya = { "ゃ" },
	lyu = { "ゅ" },
	lyo = { "ょ" },
})
vim.api.nvim_create_autocmd({ "User" }, {
	group = "MyAutoCmd",
	pattern = "skkeleton-enable-pre",
	callback = function()
		vim.b.prev_buffer_config = vim.fn["ddc#custom#get_buffer"]()
		vim.fn["ddc#custom#patch_buffer"]({
			ui = "pum",
			sources = {
				"around",
				{
					name = "skkeleton",
					options = { keywordPattern = "([ァ-ヮア-ン]|ー)+" },
				},
			},
		})
	end
})
vim.api.nvim_create_autocmd({ "User" }, {
	group = "MyAutoCmd",
	pattern = "skkeleton-disable-pre",
	callback = function()
		vim.fn["ddc#custom#set_buffer"](vim.b.prev_buffer_config)
	end
})
vim.api.nvim_create_autocmd({ "InsertLeave" }, {
	group = "MyAutoCmd",
	pattern = "*",
	callback = function()
		vim.cmd("mode")
	end
})
'''

# skk の表示をリッチにするやつ
[[plugins]]
repo = 'delphinus/skkeleton_indicator.nvim'
on_source = 'skkeleton'
lua_source = '''
local skkeleton_indicator = require('skkeleton_indicator')
skkeleton_indicator.setup({
	alwaysShown = false,
	fadeOutMs = 0,
})
'''
