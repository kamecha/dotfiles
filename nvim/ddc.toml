# 補完plugin
[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['denops.vim', 'pum.vim']
on_event = ['InsertEnter', 'CmdlineEnter']
hook_source = '''
let s:ddc_config_json =<< trim MARK
	{
		"ui": "pum",
		"sources": ["around", "nvim-lsp", "vsnip"],
		"sourceOptions": {
			"around": {
				"mark": "A"
			},
			"nvim-lsp": {
				"mark": "lsp",
				"dup": "force",
				"forceCompletionPattern": "\\.\\w*|::"
			},
			"vsnip": {
				"mark": "vsnip",
				"dup": "keep"
			},
			"cmdline": {
				"mark": "cmd"
			},
			"cmdline-history": {
				"mark": "his"
			},
			"skkeleton": {
				"mark": "skkeleton",
				"matchers": ["skkeleton"],
				"sorters": [],
				"minAutoCompleteLength": 0,
				"isVolatile": 1
			},
			"_": {
				"matchers": ["matcher_fuzzy"],
				"sorters": ["sorter_rank"]
			}
		},
		"autoCompleteEvents": [
			"InsertEnter", 
			"TextChangedI", "TextChangedP",
			"CmdlineChanged", "CmdlineEnter"
		],
		"cmdlineSources": {
			":": ["cmdline", "cmdline-history"]
		}
	}
MARK
let s:ddc_config_json = s:ddc_config_json->join('')->json_decode()
call ddc#custom#patch_global(s:ddc_config_json)
call ddc#custom#patch_filetype('gina-commit', 'specialBufferCompletion', v:true)
call ddc#enable()

" use pum.vim
autocmd CmdlineEnter * call ddc#enable_cmdline_completion()
'''

# 補完UI
[[plugins]]
repo = 'Shougo/ddc-ui-native'
on_source = 'ddc.vim'

# 独自ポップアップwindow
[[plugins]]
repo = 'Shougo/pum.vim'
hook_source = '''
"inoremap <silent><expr> <TAB>
"      \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
"      \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
"      \ '<TAB>' : ddc#manual_complete()
inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
inoremap <C-n>   <Cmd>call pum#map#select_relative(+1)<CR>
inoremap <C-p>   <Cmd>call pum#map#select_relative(-1)<CR>
inoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
inoremap <C-e>   <Cmd>call pum#map#cancel()<CR>
cnoremap <expr> <Tab>
\ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
\ ddc#map#manual_complete()
cnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
cnoremap <C-n>   <Cmd>call pum#map#select_relative(+1)<CR>
cnoremap <C-p>   <Cmd>call pum#map#select_relative(-1)<CR>
cnoremap <expr> <CR>
\ pum#visible() ? '<Cmd>call pum#map#confirm()<CR><CR>' :
\ '<CR>'
cnoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
cnoremap <C-e>   <Cmd>call pum#map#cancel()<CR>
set cedit=<C-f>

let s:pum_config_json =<< trim MARK
{
	"max_height": 10,
	"max_width": 50,
	"highlight_matches": "Red",
	"padding": true
}
MARK
let s:pum_config_json = s:pum_config_json->join('')->json_decode()

call pum#set_option(s:pum_config_json)

" autocmd InsertEnter * inoremap <CR> <Cmd>call pum#map#confirm()<CR>
" leximaの影響を受けちゃうので、insertEnterでマッピングを上書きする
" ↓ここ他人のパンツなので、暇な時に直してみる
function s:MapPumVim() abort
	imap <expr> <CR> pum#visible() 
		\ ? pum#map#confirm()
		\ : lexima#expand('<LT>CR>', 'i')
	imap <expr> <C-n> pum#visible() 
		\ ? '<Cmd>call pum#map#select_relative(1)<CR>' 
		\ : '<Cmd>call ddc#map#manual_complete()<CR>'
	imap <expr> <C-p> pum#visible() 
		\ ? '<Cmd>call pum#map#select_relative(-1)<CR>' 
		\ : '<Cmd>call ddc#map#manual_complete()<CR>'
endfunction
autocmd InsertEnter * call <SID>MapPumVim()
'''

[[plugins]]
repo = 'Shougo/ddc-ui-pum'
on_source = 'ddc.vim'

# 補完source
[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-nvim-lsp'
depends = ['denops.vim', 'ddc.vim']
on_source = 'ddc.vim'

# 補完filter
[[plugins]]
repo = 'Shougo/ddc-source-cmdline'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-source-cmdline-history'
on_source = 'ddc.vim'

# 補完filter
[[plugins]]
repo = 'Shougo/ddc-matcher_head'
on_source = 'ddc.vim'

[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-sorter_rank'
on_source = 'ddc.vim'

# スニペット
[[plugins]]
repo = 'hrsh7th/vim-vsnip'
on_source = 'ddc.vim'

[[plugins]]
repo = 'hrsh7th/vim-vsnip-integ'
depends = ['vim-vsnip']
on_source = 'ddc.vim'

# SKK
[[plugins]]
repo = 'vim-skk/skkeleton'
on_map = { 'ic' = '<Plug>(skkeleton-toggle)'}
depends = ['ddc.vim']
hook_add = '''
imap <C-j> <Plug>(skkeleton-toggle)
cmap <C-j> <Plug>(skkeleton-toggle)
'''
hook_source = '''
call skkeleton#config({ 
			\ 'globalJisyo': g:github_dir . '/skk-dev/dict/SKK-JISYO.L',
			\ 'registerConvertResult': v:true
			\})
autocmd MyAutoCmd User skkeleton-enable-pre call s:skkeleton_pre()
function! s:skkeleton_pre() abort
	let s:prev_buffer_config = ddc#custom#get_buffer()
	call ddc#custom#patch_buffer({ 'ui': 'native', 'sources': [ 'around', 'skkeleton'], 'keywordPattern': '([ァ-ヮア-ン]|ー)+' })
endfunction
autocmd MyAutoCmd User skkeleton-disable-pre call s:skkeleton_post()
function! s:skkeleton_post() abort
	" Restore sources
	call ddc#custom#set_buffer(s:prev_buffer_config)
endfunction
function L_skkeleton_get_mode()
	if (mode() == 'i') && skkeleton#is_enabled()
		let skkeleton_mode = skkeleton#mode()
		if skkeleton_mode == 'hira'
			return 'あ'
		endif
		if skkeleton_mode == 'kata'
			return 'ア'
		endif
		if skkeleton_mode == 'hankata'
			return 'ｱ'
		endif
		if skkeleton_mode == 'zenkaku'
			return 'Ａ'
		endif
		if skkeleton_mode == 'abbrev'
			return 'A'
		endif
		return ''
	else
		return ''
	endif
endfunction
let g:lightline = { 'component_function': { 'skkeleton' : 'L_skkeleton_get_mode'} }
" これ何か分ってない
" :mode is needed to redraw screen
autocmd MyAutoCmd InsertLeave * mode
'''

# skk の表示をリッチにするやつ
[[plugins]]
repo = 'delphinus/skkeleton_indicator.nvim'
on_source = 'skkeleton'
hook_source = '''
lua << EOF
local skkeleton_indicator = require('skkeleton_indicator')
skkeleton_indicator.setup({
	alwaysShown = false,
	fadeOutMs = 0,
})
EOF
'''
